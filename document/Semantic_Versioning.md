# 시맨틱 버전 관리(Semantic Versioning)
> 버전 관리를 처음 해 보아서 '시맨틱 버전 관리'에 대해 정리해 보았습니다.  

<br>

프로그램을 수정하고 다시 배포할 때 버전 번호를 매기는 방법은 일반적으로 **시맨틱 버전 관리(Semantic Versioning)**라는 규칙을 따릅니다. 이 방식은 버전 번호를 세 부분으로 나누어 변경 사항의 중요도를 나타냅니다.

<br>

## 시맨틱 버전 관리 규칙
> 버전 번호는 보통 **`MAJOR.MINOR.PATCH`** 형식으로 구성됩니다.  

* **PATCH (패치):** 가장 오른쪽의 숫자입니다.  
    버그 수정, 오타 수정 등 **기능 변경이 없는 작은 수정**이 있을 때 1씩 증가시킵니다.
    * 예시: `1.0.0`에서 오타를 수정했다면 `1.0.1`로 변경합니다.
* **MINOR (마이너):** 중간의 숫자입니다.  
    **하위 호환성을 유지하면서 새로운 기능이 추가**되었을 때 1씩 증가시키고, 패치 번호는 0으로 초기화합니다.
    * 예시: `1.0.1`에서 새로운 알림 시간 설정 기능을 추가했다면 `1.1.0`으로 변경합니다.
* **MAJOR (메이저):** 가장 왼쪽의 숫자입니다.   
    **하위 호환성을 깨는 큰 변화**나 완전히 새로운 기능이 추가되었을 때 1씩 증가시키고, 마이너와 패치 번호는 0으로 초기화합니다.
    * 예시: `1.1.0`에서 데이터 저장 방식(CSV → DB)을 완전히 변경하여 기존 버전과 호환되지 않는다면 `2.0.0`으로 변경합니다.

---

## 실제 적용 사례
> 사용자님의 프로그램에 이 규칙을 적용하면 다음과 같이 버전을 관리할 수 있습니다.  

* **첫 배포:** `1.0.0`
* **자동 실행 체크박스 버그 수정:**
    * **변경 내용:** 버그 수정
    * **새 버전:** `1.0.1`
* **새로운 분석 지표(예: RSI) 추가:**
    * **변경 내용:** 새로운 기능 추가 (하위 호환성 유지)
    * **새 버전:** `1.1.0`
* **API를 완전히 다른 곳으로 교체:**
    * **변경 내용:** 하위 호환성을 깨는 큰 변경
    * **새 버전:** `2.0.0`

이러한 규칙을 따르면 사용자나 다른 개발자가 버전 번호만 보고도 해당 업데이트에 어떤 종류의 변경이 포함되었는지 쉽게 파악할 수 있습니다.